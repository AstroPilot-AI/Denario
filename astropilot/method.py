import os
import re
import cmbagent

class Method:
    """
    This class is used to develop a research project methodology based on the data of interest and the project idea.

    Args:
        work_dir: working directory.
    """

    def __init__(self, research_idea: str, work_dir = None):

        if work_dir is None:
            raise ValueError("workdir must be provided")

        self.method_dir = os.path.join(work_dir, "method_generation_output")
        # Create directory if it doesn't exist
        os.makedirs(self.method_dir, exist_ok=True)
        self.planner_append_instructions = rf"""

        {research_idea}

Instruction for planning:

Given these datasets, and information on the features and project idea, we want to design a methodology to implement this idea.
The goal of the task is to write a plan that will be used to generate a detailed description of the methodology that will be used to perform the research project.

**Elicit Project-Specific Reasoning:**
   - Ask the *researcher* to provide reasoning  relevant to the given project idea.
   - Clarify the specific hypotheses, assumptions, or questions that should be investigated.
   - This can be done in multiple steps. 


**MOST IMPORTANT: Write the Methodology description:**
   - With the *researcher*, write a **detailed description (approximately 500 words)** describing the methodology that will be used to perform the project analysis.
   - The description should clearly outline the steps, techniques, and rationale derived from the exploratory data analysis.
   - If EDA was performed, include relevant results from the EDA in the form of key statistics or tables (do not include references to plots, or generated files here).
   - The focus should be strictly on the methods and workflow for this specific project to be performed. **do not include** any discussion of future directions, future work, project extensions, or limitations.
   - The description should be written as if it were a senior researcher explaining to her research assistant how to perform the research necessary for this project.

The plan must end with the Methodology description generated by the researcher. The final step of the plan must be such that the FULL Methodology description is provided (as a result of the previous steps).

The only agent involved in this workflow is the researcher.

In this task we do not perform any calculations or analyses, only outline the methodology. 

The methodology should focus on describing the research and analysis that will be performed.

"""

        # self.plan_reviewer_append_instructions = rf"""
        #     {research_idea}

        #     Check that the agents called in each sub-task only include, if needed: 
        #     - engineer: an expert Python coder who writes entire Python pipelines ready to be executed. It does not aim to discuss the results of the code, only to write the code.
        #     - researcher: an expert researcher that produces reasoning. This agents also discusses results. 

        #     The plan must end with the Methodology description generated by the researcher. It is in 4 steps with:
        #     researcher->engineer->researcher->researcher

        #     The exploratory data analysis is intended to refine and inform the methodology for the research project. In this task we do not perform the full research, only outline the methodology. 

        # """

        # self.engineer_append_instructions = rf"""
        # {research_idea}

        # Given these datasets, and information on the features and project idea, we want to design a methodology to implement this idea.
        # The goal of the task is to generate a detailed description of the methodology that will be used to carry out the research project.

        # Warnings: 
        # Some feature columns may have a large number of non-null entries. Although vectorized operations (like np.percentile, np.concatenate) are efficient, they do take longer on larger arrays. 
        # You must make sure the code is well optimized for operations on large arrays. 

        # For plots involving features: 
        # - making sure dynamical ranges are well captured (carefully adjust the binning, and log or linear axes scales, for each feature).
        # For histograms (if needed):
        # - Use log-scale for features with values spanning several orders of magnitudes. 
        # - Don't include null or nan values in the histogram counts, nonetheless, although the NaN entries are useless, it might be useful to keep track of the zero counts for some features.

        # """


        self.researcher_append_instructions = rf"""
       {research_idea}

        Given these datasets, and information on the features and project idea, we want to design a methodology to implement this idea.
        The goal of the task is to write a detailed description of the methodology that will be used to carry out the research project.

        - When asked about generating the Methodology description, your focus should be strictly on the statistical and machine learning methods for this specific project to be performed. **Do not include** any discussion of future directions, future work, project extensions, or limitations.
        - The methodology description should be written as if it were a senior researcher explaining to her research assistant how to perform the project. 

        The designed methodology should focus on describing the research and analysis that will be performed.
        """

    def develop_method(self, data_description: str, **kwargs):
        """
        Develops the methods based on the data description.

        Args:
            data_description: description of the data and tools to be used.
        """

        # ## planning
        # cmbagent = CMBAgent()
        # cmbagent.solve(data_description,
        #             max_rounds=500,
        #             initial_agent="planner",
        #             shared_context = {'feedback_left': 1,
        #                                 'maximum_number_of_steps_in_plan': 4,
        #                                 'planner_append_instructions': self.planner_append_instructions,
        #                                 'engineer_append_instructions': self.engineer_append_instructions,
        #                                 'researcher_append_instructions': self.researcher_append_instructions,
        #                                 'plan_reviewer_append_instructions': self.plan_reviewer_append_instructions}
        #             )
        
        # planning_output = copy.deepcopy(cmbagent.final_context)
        
        # ## control
        # cmbagent = CMBAgent(
        # agent_llm_configs = {
        #                     'engineer': {
        #                         "model": "o3-mini-2025-01-31",
        #                         "reasoning_effort": "high",
        #                         "api_key": os.getenv("OPENAI_API_KEY"),
        #                         "api_type": "openai"},
        #                     'researcher': {
        #                         "model": "o3-mini-2025-01-31",
        #                         "reasoning_effort": "medium",
        #                         "api_key": os.getenv("OPENAI_API_KEY"),
        #                         "api_type": "openai"},
        # })
        

        # cmbagent.solve(data_description,
        #             max_rounds=500,
        #             initial_agent="control",
        #             shared_context = planning_output
        #             )

        results = cmbagent.planning_and_control(data_description,
                              n_plan_reviews = 1,
                              max_n_attempts = 4,
                              max_plan_steps = 4,
                            #   engineer_model = "gpt-4.1-2025-04-14",
                              researcher_model = "gpt-4.1-2025-04-14",
                              plan_instructions=self.planner_append_instructions,
                              researcher_instructions=self.researcher_append_instructions,
                              work_dir = self.method_dir
                            #   engineer_instructions=self.engineer_append_instructions
                             )
        
        chat_history = results['chat_history']
        # final_context = results['final_context']
        
        try:
            for obj in chat_history[::-1]:
                if obj['name'] == 'researcher_response_formatter':
                    result = obj['content']
                    break
            task_result = result
        except:
            task_result = None
        MD_CODE_BLOCK_PATTERN = r"```[ \t]*(?:markdown)[ \t]*\r?\n(.*)\r?\n[ \t]*```"
        extracted_methodology = re.findall(MD_CODE_BLOCK_PATTERN, task_result, flags=re.DOTALL)[0]
        clean_methodology = re.sub(r'^<!--.*?-->\s*\n', '', extracted_methodology)
        return clean_methodology